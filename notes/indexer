includes

 - At an #include (and include_next,import) directive, we need to record the
   full path of the included file, and the source range of the filename.
   (Can we say that the file is a symbol, then record a ref to it?)

Find more user-friendly symbol names than USRs.

 - Do USRs go away entirely?  Is there a one-to-one or a one-to-many
   relationship between a USR and a user-friendly name?  If USRs are still
   present, then will their existence make navigator behavior magical/opaque?

Template arguments

 - Instead of recording a std::vector<Foo*, std::allocator<Foo*>>, we can
   record one of:
    - std::vector
    - std::vector<Foo*>
   I'm not aware of a downside to omitting template arguments that match the
   default.  I'm not sure it's really feasible.  Omitting the template arguments
   entirely has the advantage of reducing the number of symbols at a single
   source point (but it doesn't solve the problem -- consider preprocessor
   usage).  It means that I could xref on std::vector::push_back to see all uses
   of that method regardless of the contained type.

Ref ranges

 - For refs, try to get range info (start+stop) rather than just a location.
   This is needed for C++ destructors because "~ Foo" is not an identifier, but
   we'd probably like the whole thing to be treated like one.  (Actually, can
   there be comments in there?)

Highlighting

 - For highlighting, we want to differentiate between kinds of symbols:
    - types
    - members
    - local variables

BUGs (bad ref kinds)

 - For "class A : T<A>" we record A as a Base-Class.  It should be something
   else, maybe just Reference.
 - See notes/misc for more.

Special buffers (scratch space, built-in macros)

 - I keep seeing references to "<scratch space>" and "<built-in>".  They ought
   to go away.  Maybe some of the scratch space references have something to
   do with the preprocessor and with the way the indexer deals with macros
   and source locations.

 - For "<built-in>" (and command-line -D/-U args?), the ideal fix probably goes
   like this.  We'd have a special table ("builtins") mapping USRs for built-in
   macro definitions to a string with the expanded tokens.  Then at some point,
   we'd read this table and turn it into a special buffer.  Something like this:
      /*built-in*/ FOO => 1
      /*built-in*/ FOO => 0
      /*cmd-line*/ FOO => 1
      /*cmd-line*/ FOO => undef
      /*built-in*/ #define BAR 1
      /*built-in*/ #define BAZ 1
   We could do this transformation right before writing the completed index
   file, or we could do in the navigator itself.  Each line in the special
   buffer implies one extra ref.  (I assume the values themselves don't refer
   to other macros, but I don't know that for sure.)  If the transformation is
   done at index time, then we can create the refs then, but we need to store
   the buffer in the index ("special-buffers" table, with one column mapping
   "<built-in>" to the content?).  If the transformation is done at run-time,
   then the navigator will have to augment the ref query to add in the built-in
   refs.

   DECISION: I think the transformation should be done at index-time so as to
   keep more C/C++-specific code out of the navigator.

   LATER(2012-10-08): What happens if multiple projects' indices are merged
   together (where each project's index was itself generated by merging TU
   indices)?

----

For C++, include parameter type names to handle overloading:

std::vector::push_back(A*)

For symbols with internal linkage:

    basename.h/static_function
    basename.h/foo::<anon>::function

Templates: -- omit the template params entirely

    PROBLEM: What about function overloading?  Suppose there are two
    functions:
        int func(std::vector<int> &vi)
        int func(std::vector<double &vd)
    Would we represent both as this?
        func(std::vector&)

----

Problem at llvm/include/llvm/ADT/SmallVector.h, lines 273.
There is no ref on SmallVectorTemplateBase or value.

    class SmallVectorImpl : public SmallVectorTemplateBase<T, isPodLike<T>::value> {

----

Calls to the clang::VarDecl(Kind, DeclContext, ...) ctor seem to be missing
from the refs info.  Also review whether calls to dtors are in the refs info.
This might be a difficult thing to fix -- a lot of these calls are implicit.
Image what happens with std::vector<SomeType> -- where are calls to
SomeType::~SomeType coming from?  Implicit conversions are probably related.

----

This is probably mentioned elsewhere, but record it here anyway.  The Curiously
Recurring Template Pattern appears repeatedly in LLVM+Clang, and the Derived
class appears as a Base-Class ref.  It should appear as just a Reference.

----

BUG: The new symbol naming code tends to leave off the filename, and I think
it always omits the file offset.  It should include both except when C/C++
allows something (of external linkage) to be declared in multiple places.
Example:
    int main(int argc, char *argv) {
        { int p1 = 10; }
        { int p1 = 20; }
    }
Symbols that currently exist:
    main
    main::argc
    main::argv
    main::p1
Symbols that should exist:
    main
    file.cc@10/argc
    file.cc@20/argv
    file.cc@30/p1
    file.cc@40/p1

Local variable and parameters are always declared in one place, so even though
main::argc would be unique across a single program (barring a local variable
named argc), an index can include multiple main functions, so the
filename/offset is still useful.

----

BUG: I'm seeing a lot of these errors indexing Qt:

     error: unable to read PCH file: 'Is a directory'

----

BUG: We need to detect when the same object file path is generated twice and do
the right thing.  It's currently possible for clang-indexer to start two
parallel jobs that write the same idx file with --incremental, and bad things
can happen when a corrupted file is read in for merging.

 - Need to decide where to address this issue: in clang-indexer and/or in
   processlog.py.

----

TODO: How does the btrace processlog.py file deal with commands that output PCH
files.

TODO: Consider renaming processlog.py to match what I think is an existing
naming convention in LLVM for scripts that generate compile_commands.json.

TODO: Regarding PCH, consider that the build compiler could be Clang, but a
different version of Clang than the one used by clang-indexer, so its PCH files
would still be incompatible.  If clang-indexer just checks the 4-byte signature
at the start of the PCH file, then it will fail to detect the incompatibility.

See http://marc.info/?l=cfe-commits&m=128713917112525 regarding Qt, Clang, and
PCH.

----

BUG: In LLVM, line 41 of include/llvm/SymbolTableListTraits.h, why are there
no references on ilist_default_traits?  Similarly, getSymTab on line 32 of
/home/rprichard/llvm/lib/VMCore/SymbolTableListTraitsImpl.h also has no
references.
